<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>ROOM · AEMX</title>
  <link rel="icon" type="image/png" href="imagen_1.png">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #060b14;
      --glow: #00c8ff;
      --gold: #ffd700;
      --text2: #6b8ab0;
      --border: #1a3a5c;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      background: var(--bg);
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      font-family: 'Share Tech Mono', monospace;
      cursor: none;
    }

    body::before {
      content: '';
      position: fixed;
      inset: 0;
      background-image:
        linear-gradient(rgba(0,200,255,0.04) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0,200,255,0.04) 1px, transparent 1px);
      background-size: 48px 48px;
      animation: gridMove 25s linear infinite;
      pointer-events: none;
      z-index: 0;
    }
    @keyframes gridMove {
      0%   { transform: translateY(0); }
      100% { transform: translateY(48px); }
    }

    body::after {
      content: '';
      position: fixed;
      inset: 0;
      background:
        radial-gradient(ellipse at 15% 20%, rgba(0,200,255,0.06) 0%, transparent 55%),
        radial-gradient(ellipse at 85% 80%, rgba(255,215,0,0.05) 0%, transparent 55%);
      pointer-events: none;
      z-index: 0;
    }

    #canvas {
      position: fixed;
      inset: 0;
      z-index: 1;
      touch-action: none;
    }

    /* HUD superior */
    .hud {
      position: fixed;
      top: 0; left: 0; right: 0;
      z-index: 10;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 14px 20px;
      border-bottom: 1px solid rgba(0,200,255,0.12);
      background: rgba(6,11,20,0.7);
      backdrop-filter: blur(12px);
    }

    .hud-title {
      font-family: 'Orbitron', monospace;
      font-size: 13px;
      font-weight: 900;
      letter-spacing: 5px;
      color: var(--glow);
      text-shadow: 0 0 20px rgba(0,200,255,0.5);
    }

    .hud-right {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .online-count {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 11px;
      color: var(--text2);
      letter-spacing: 2px;
    }

    .online-dot {
      width: 7px; height: 7px;
      border-radius: 50%;
      background: #00ff9d;
      box-shadow: 0 0 8px #00ff9d;
      animation: pulse 1.5s ease infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50%       { opacity: 0.4; transform: scale(0.7); }
    }

    .online-num {
      font-family: 'Orbitron', monospace;
      font-size: 16px;
      font-weight: 700;
      color: #00ff9d;
    }

    .btn-back {
      background: none;
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text2);
      font-family: 'Share Tech Mono', monospace;
      font-size: 11px;
      letter-spacing: 1px;
      padding: 5px 12px;
      cursor: pointer;
      text-decoration: none;
      transition: all 0.2s;
    }
    .btn-back:hover { border-color: var(--glow); color: var(--glow); }

    /* Cursor personalizado */
    #cursor {
      position: fixed;
      width: 12px; height: 12px;
      border: 2px solid var(--glow);
      border-radius: 50%;
      pointer-events: none;
      z-index: 100;
      transform: translate(-50%, -50%);
      transition: transform 0.1s ease;
      box-shadow: 0 0 10px rgba(0,200,255,0.6);
    }

    /* Loading */
    .loading {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 20;
      gap: 16px;
    }
    .loading-ring {
      width: 48px; height: 48px;
      border: 2px solid var(--border);
      border-top-color: var(--glow);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .loading-text {
      font-family: 'Orbitron', monospace;
      font-size: 10px;
      color: var(--text2);
      letter-spacing: 3px;
    }

    /* Toast */
    .toast {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%) translateY(60px);
      background: rgba(11,22,38,0.95);
      border: 1px solid var(--glow);
      border-radius: 8px;
      padding: 8px 20px;
      font-size: 11px;
      color: var(--glow);
      letter-spacing: 1px;
      z-index: 50;
      transition: transform 0.3s ease, opacity 0.3s ease;
      opacity: 0;
      white-space: nowrap;
    }
    .toast.show { transform: translateX(-50%) translateY(0); opacity: 1; }

    /* ── BARRA DE MENSAJE ── */
    #msg-bar {
      position: fixed;
      bottom: 0; left: 0; right: 0;
      z-index: 15;
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 16px;
      background: rgba(6,11,20,0.85);
      backdrop-filter: blur(16px);
      border-top: 1px solid rgba(0,200,255,0.15);
    }

    #msg-input {
      flex: 1;
      background: rgba(0,200,255,0.05);
      border: 1px solid rgba(0,200,255,0.2);
      border-radius: 8px;
      color: #cce8f4;
      font-family: 'Share Tech Mono', monospace;
      font-size: 13px;
      padding: 9px 14px;
      outline: none;
      transition: border-color 0.2s, box-shadow 0.2s;
      caret-color: var(--glow);
      cursor: text;
    }
    #msg-input::placeholder { color: rgba(107,138,176,0.5); }
    #msg-input:focus {
      border-color: rgba(0,200,255,0.55);
      box-shadow: 0 0 12px rgba(0,200,255,0.12);
    }

    #msg-send {
      background: rgba(0,200,255,0.1);
      border: 1px solid rgba(0,200,255,0.35);
      border-radius: 8px;
      color: var(--glow);
      font-family: 'Orbitron', monospace;
      font-size: 10px;
      font-weight: 700;
      letter-spacing: 2px;
      padding: 9px 18px;
      cursor: pointer;
      transition: all 0.2s;
      white-space: nowrap;
    }
    #msg-send:hover {
      background: rgba(0,200,255,0.2);
      border-color: var(--glow);
      box-shadow: 0 0 14px rgba(0,200,255,0.25);
    }
    #msg-send:active { transform: scale(0.96); }

    /* hint de atajos */
    #msg-hint {
      font-size: 10px;
      color: rgba(107,138,176,0.4);
      letter-spacing: 1px;
      white-space: nowrap;
    }
  
    @media (hover: none) {
      #cursor { display: none !important; }
    }

  </style>
</head>
<body>

  <!-- HUD -->
  <div class="hud">
    <div class="hud-title">⬡ ROOM AEMX</div>
    <div class="hud-right">
      <div class="online-count">
        <div class="online-dot"></div>
        <span class="online-num" id="onlineNum">0</span>
        <span>EN LÍNEA</span>
      </div>
      <a href="index.html" class="btn-back">← VOLVER</a>
    </div>
  </div>

  <!-- Canvas -->
  <canvas id="canvas"></canvas>

  <!-- Cursor -->
  <div id="cursor"></div>

  <!-- Loading -->
  <div class="loading" id="loading">
    <div class="loading-ring"></div>
    <div class="loading-text">CONECTANDO...</div>
  </div>

  <!-- Toast -->
  <div class="toast" id="toast"></div>

  <!-- Barra de mensajes -->
  <div id="msg-bar">
    <input id="msg-input" type="text" placeholder="Escribe un mensaje... (Enter para enviar)" maxlength="120" autocomplete="off" spellcheck="false">
    <span id="msg-hint">↵ ENVIAR</span>
    <button id="msg-send">TRANSMITIR</button>
  </div>

  <script type="module">
    import { initializeApp }  from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js';
    import { getAuth, onAuthStateChanged, GoogleAuthProvider, signInWithPopup }
                              from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js';
    import { getDatabase, ref, set, onValue, onChildAdded, onDisconnect, serverTimestamp, remove, push, query, limitToLast }
                              from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js';

    const firebaseConfig = {
      apiKey:        'AIzaSyB-xx2PlBjvnHe0K7Bf1MspVqUlfjky0mk',
      authDomain:    'aemx-chat.firebaseapp.com',
      databaseURL:   'https://aemx-chat-default-rtdb.firebaseio.com',
      projectId:     'aemx-chat',
      storageBucket: 'aemx-chat.appspot.com',
    };

    const app  = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db   = getDatabase(app);

    // ── Canvas setup ──
    const canvas  = document.getElementById('canvas');
    const ctx     = canvas.getContext('2d');
    const loading = document.getElementById('loading');
    const cursorEl= document.getElementById('cursor');

    function resize() {
      canvas.width  = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    // ── Constantes de física ──
    // Tamaño visual del avatar: ~1/3 más pequeño (de 44 → ~29)
    const AVATAR_RADIUS    = 29;

    // Área para agarrar/arrastrar (más grande para móviles)
    const HIT_RADIUS       = 42;

    // Área de colisión (más grande que el visual, como “hitbox”)
    const COLLISION_RADIUS = 52;

    const FRICTION = 0.88;
    const REPULSE  = 0.38;
const TOP_PAD  = 60;
    const BOT_PAD  = 56; // espacio para la barra de mensajes

    const bubbles  = new Map(); // uid → burbuja
    const imgCache = new Map(); // url → HTMLImageElement

    // ── Globos de diálogo ──
    // Cada globo: { uid, text, born, duration, alpha, lines, boxW, boxH }
    const speechBubbles = [];
    const BUBBLE_DURATION = 6000; // ms que dura el globo
    const MSG_MAX_WIDTH   = 220;  // ancho máximo del texto

    function loadImg(url) {
      if (!url) return null;
      if (imgCache.has(url)) return imgCache.get(url);
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.src = url;
      imgCache.set(url, img);
      return img;
    }

    function createBubble(uid, data) {
      return {
        uid,
        username:    data.username || '?',
        avatar:      data.avatar   || '',
        borderColor: data.borderColor || '#00c8ff',
        photoURL:    data.photoURL || '',
        x: COLLISION_RADIUS + Math.random() * (canvas.width  - COLLISION_RADIUS * 2),
        y: TOP_PAD + COLLISION_RADIUS + Math.random() * (canvas.height - TOP_PAD - BOT_PAD - COLLISION_RADIUS * 2),
        vx: (Math.random() - 0.5) * 2,
        vy: (Math.random() - 0.5) * 2,
        ringAngle: Math.random() * Math.PI * 2,
        img: null,
        pulse: 0,
      };
    }

    // ── Física ──
    let mouseX = canvas.width  / 2;
let mouseY = canvas.height / 2;
let myUid  = null;

// ── Drag del avatar (solo arrastrar; ya NO sigue al mouse) ──
const drag = {
  active: false,
  pointerId: null,
  offsetX: 0,
  offsetY: 0,
};

function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

function isOverBubble(b, px, py) {
  // Hit-test simple en coordenadas del canvas
  const dx = px - b.x;
  const dy = py - b.y;
  return (dx * dx + dy * dy) <= (HIT_RADIUS * HIT_RADIUS);
}

function pointerPos(e) {
  const rect = canvas.getBoundingClientRect();
  return { x: e.clientX - rect.left, y: e.clientY - rect.top };
}

    function updatePhysics() {
  const bArr = [...bubbles.values()];
  const canvasH = canvas.height - BOT_PAD;

  const cx = canvas.width / 2;
  const cy = (TOP_PAD + canvasH) / 2;

  for (let i = 0; i < bArr.length; i++) {
    const b = bArr[i];
    const isMe = (b.uid === myUid);

    // Si estoy siendo arrastrado, no aplicamos atracción ni integración por velocidad aquí
    // (la posición se controla con el drag handler).
    if (!(isMe && drag.active)) {

      b.vx *= FRICTION;
      b.vy *= FRICTION;
      b.x += b.vx;
      b.y += b.vy;
    } else {
      b.vx = 0;
      b.vy = 0;
    }

    // Límites del área jugable
    if (b.x < COLLISION_RADIUS)                { b.x = COLLISION_RADIUS;                b.vx *= -0.5; }
    if (b.x > canvas.width - COLLISION_RADIUS) { b.x = canvas.width - COLLISION_RADIUS; b.vx *= -0.5; }
    if (b.y < TOP_PAD + COLLISION_RADIUS)      { b.y = TOP_PAD + COLLISION_RADIUS;      b.vy *= -0.5; }
    if (b.y > canvasH - COLLISION_RADIUS)      { b.y = canvasH - COLLISION_RADIUS;      b.vy *= -0.5; }

    // Repulsión entre avatares
    for (let j = i + 1; j < bArr.length; j++) {
      const o  = bArr[j];
      const dx = o.x - b.x;
      const dy = o.y - b.y;
      const dist = Math.sqrt(dx * dx + dy * dy) || 0.01;
      const minDist = COLLISION_RADIUS * 2 + 8;

      if (dist < minDist) {
        const force = (minDist - dist) / minDist * REPULSE;
        const nx = dx / dist, ny = dy / dist;

        // Si estoy arrastrando mi avatar, lo tratamos como "inmóvil":
        // empuja al otro, pero no me empuja a mí.
        if (b.uid === myUid && drag.active) {
          o.vx += nx * force * 2;
          o.vy += ny * force * 2;
        } else if (o.uid === myUid && drag.active) {
          b.vx -= nx * force * 2;
          b.vy -= ny * force * 2;
        } else {
          b.vx -= nx * force;
          b.vy -= ny * force;
          o.vx += nx * force;
          o.vy += ny * force;
        }
      }
    }

    b.ringAngle += 0.008;
    if (b.pulse < 1) b.pulse = Math.min(1, b.pulse + 0.04);
  }
}

// ── Utilidades de texto ──
    function wrapText(text, maxWidth) {
      ctx.font = '12px "Share Tech Mono", monospace';
      const words = text.split(' ');
      const lines = [];
      let current = '';

      for (const word of words) {
        const test = current ? current + ' ' + word : word;
        if (ctx.measureText(test).width > maxWidth && current) {
          lines.push(current);
          current = word;
        } else {
          current = test;
        }
      }
      if (current) lines.push(current);
      return lines;
    }

    // ── Dibujar globo de diálogo ──
    function drawSpeechBubbles() {
      const now = performance.now();

      for (let i = speechBubbles.length - 1; i >= 0; i--) {
        const sb = speechBubbles[i];
        const bubble = bubbles.get(sb.uid);
        if (!bubble) { speechBubbles.splice(i, 1); continue; }

        const elapsed = now - sb.born;
        if (elapsed > sb.duration) { speechBubbles.splice(i, 1); continue; }

        // fade in/out
        let alpha = 1;
        const fadeIn  = 300;
        const fadeOut = 800;
        if (elapsed < fadeIn) {
          alpha = elapsed / fadeIn;
        } else if (elapsed > sb.duration - fadeOut) {
          alpha = (sb.duration - elapsed) / fadeOut;
        }
        alpha = Math.max(0, Math.min(1, alpha));

        const { x, y } = bubble;
        const color = bubble.borderColor || '#00c8ff';

        // Calcular dimensiones del box
        ctx.font = '12px "Share Tech Mono", monospace';
        const lineH = 17;
        const padX  = 12, padY = 9;
        const boxW  = sb.boxW;
        const boxH  = sb.lines.length * lineH + padY * 2;

        // Posición del globo (arriba del avatar)
        const tailH  = 10;
        const bx     = x - boxW / 2;
        const by     = y - AVATAR_RADIUS - tailH - boxH - 8;

        ctx.save();
        ctx.globalAlpha = alpha;

        // Fondo del globo
        const fillColor = hexToRgba(color, 0.12);
        const borderCol = hexToRgba(color, 0.75);

        // Sombra glow
        ctx.shadowColor = color;
        ctx.shadowBlur  = 18;

        // Cuerpo del globo (rounded rect)
        const rx = 10;
        ctx.beginPath();
        ctx.moveTo(bx + rx, by);
        ctx.lineTo(bx + boxW - rx, by);
        ctx.quadraticCurveTo(bx + boxW, by, bx + boxW, by + rx);
        ctx.lineTo(bx + boxW, by + boxH - rx);
        ctx.quadraticCurveTo(bx + boxW, by + boxH, bx + boxW - rx, by + boxH);
        // cola del globo
        const midX = x;
        ctx.lineTo(midX + 8, by + boxH);
        ctx.lineTo(midX, by + boxH + tailH);
        ctx.lineTo(midX - 8, by + boxH);
        ctx.lineTo(bx + rx, by + boxH);
        ctx.quadraticCurveTo(bx, by + boxH, bx, by + boxH - rx);
        ctx.lineTo(bx, by + rx);
        ctx.quadraticCurveTo(bx, by, bx + rx, by);
        ctx.closePath();

        ctx.fillStyle = fillColor;
        ctx.fill();

        ctx.shadowBlur = 0;
        ctx.strokeStyle = borderCol;
        ctx.lineWidth   = 1.5;
        ctx.stroke();

        // Texto
        ctx.shadowColor = color;
        ctx.shadowBlur  = 6;
        ctx.fillStyle   = '#e8f4ff';
        ctx.font        = '12px "Share Tech Mono", monospace';
        ctx.textAlign   = 'left';
        ctx.textBaseline= 'top';

        sb.lines.forEach((line, idx) => {
          ctx.fillText(line, bx + padX, by + padY + idx * lineH);
        });

        ctx.restore();
      }
    }

    // ── Recibir mensaje y crear globo ──
    function addSpeechBubble(uid, text) {
      // Calcular ancho máximo según canvas
      const maxW = Math.min(MSG_MAX_WIDTH, canvas.width * 0.4);
      ctx.font = '12px "Share Tech Mono", monospace';
      const lines = wrapText(text, maxW - 24);
      let boxW = 0;
      lines.forEach(l => { boxW = Math.max(boxW, ctx.measureText(l).width + 24); });
      boxW = Math.max(boxW, 80);

      // Eliminar globo anterior del mismo uid
      const existIdx = speechBubbles.findIndex(sb => sb.uid === uid);
      if (existIdx !== -1) speechBubbles.splice(existIdx, 1);

      speechBubbles.push({
        uid,
        text,
        born: performance.now(),
        duration: BUBBLE_DURATION,
        lines,
        boxW,
      });
    }

    // ── Dibujar avatar ──
    function drawBubble(b) {
      const { x, y, username, borderColor, avatar, photoURL, ringAngle, pulse } = b;
      const scale = 0.4 + pulse * 0.6;
      const r = AVATAR_RADIUS * scale;
      const isMe = b.uid === myUid;

      ctx.save();
      ctx.translate(x, y);
      ctx.scale(scale, scale);

      ctx.shadowColor = borderColor;
      ctx.shadowBlur  = isMe ? 28 : 16;

      const ringR    = AVATAR_RADIUS + 10;
      const segments = 12;
      for (let i = 0; i < segments; i++) {
        const a1 = ringAngle + (i / segments) * Math.PI * 2;
        const a2 = a1 + (Math.PI * 2 / segments) * 0.6;
        const alpha = (i % 2 === 0) ? 0.9 : 0.25;
        ctx.beginPath();
        ctx.arc(0, 0, ringR, a1, a2);
        ctx.strokeStyle = hexToRgba(borderColor, alpha);
        ctx.lineWidth   = isMe ? 3.5 : 2.5;
        ctx.lineCap     = 'round';
        ctx.stroke();
      }
      ctx.shadowBlur = 0;

      ctx.beginPath();
      ctx.arc(0, 0, AVATAR_RADIUS, 0, Math.PI * 2);
      ctx.clip();

      ctx.fillStyle = '#0b1626';
      ctx.fill();

      const imgSrc = photoURL || avatar;
      if (imgSrc) {
        const img = loadImg(imgSrc);
        if (img && img.complete && img.naturalWidth > 0) {
          try {
            ctx.drawImage(img, -AVATAR_RADIUS, -AVATAR_RADIUS, AVATAR_RADIUS * 2, AVATAR_RADIUS * 2);
          } catch(e) {
            drawInitial(ctx, username, borderColor);
          }
        } else {
          drawInitial(ctx, username, borderColor);
        }
      } else {
        drawInitial(ctx, username, borderColor);
      }

      ctx.restore();

      ctx.save();
      ctx.translate(x, y);
      ctx.beginPath();
      ctx.arc(0, 0, r, 0, Math.PI * 2);
      ctx.strokeStyle = hexToRgba(borderColor, 0.7);
      ctx.lineWidth   = 2;
      ctx.shadowColor = borderColor;
      ctx.shadowBlur  = 10;
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.translate(x, y);
      const label = isMe ? `${username} ◀` : username;
      ctx.font         = `bold ${isMe ? 11 : 10}px "Share Tech Mono", monospace`;
      ctx.textAlign    = 'center';
      ctx.textBaseline = 'top';
      const tw = ctx.measureText(label).width;
      ctx.fillStyle = 'rgba(6,11,20,0.85)';
      ctx.beginPath();
      ctx.roundRect(-tw/2 - 6, r + 6, tw + 12, 18, 4);
      ctx.fill();
      ctx.fillStyle   = isMe ? '#ffd700' : borderColor;
      ctx.shadowColor = isMe ? '#ffd700' : borderColor;
      ctx.shadowBlur  = 6;
      ctx.fillText(label, 0, r + 8);
      ctx.restore();
    }

    function drawInitial(ctx, username, color) {
      const letter = (username || '?').charAt(0).toUpperCase();
      ctx.fillStyle = hexToRgba(color, 0.18);
      ctx.fillRect(-AVATAR_RADIUS, -AVATAR_RADIUS, AVATAR_RADIUS * 2, AVATAR_RADIUS * 2);
      ctx.font         = `bold ${AVATAR_RADIUS * 0.9}px "Orbitron", monospace`;
      ctx.textAlign    = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle    = color;
      ctx.shadowColor  = color;
      ctx.shadowBlur   = 12;
      ctx.fillText(letter, 0, 2);
    }

    function hexToRgba(hex, alpha) {
      if (!hex || !hex.startsWith('#')) return `rgba(0,200,255,${alpha})`;
      const r = parseInt(hex.slice(1,3), 16);
      const g = parseInt(hex.slice(3,5), 16);
      const b = parseInt(hex.slice(5,7), 16);
      return `rgba(${r},${g},${b},${alpha})`;
    }

    // ── Loop principal ──
    function loop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const bArr = [...bubbles.values()];
      for (let i = 0; i < bArr.length; i++) {
        for (let j = i + 1; j < bArr.length; j++) {
          const a = bArr[i], b = bArr[j];
          const dx = b.x - a.x, dy = b.y - a.y;
          const dist = Math.sqrt(dx*dx + dy*dy);
          const maxDist = 180;
          if (dist < maxDist) {
            const alpha = (1 - dist / maxDist) * 0.15;
            ctx.beginPath();
            ctx.moveTo(a.x, a.y);
            ctx.lineTo(b.x, b.y);
            ctx.strokeStyle = `rgba(0,200,255,${alpha})`;
            ctx.lineWidth   = 1;
            ctx.stroke();
          }
        }
      }

      updatePhysics();
      bArr.forEach(drawBubble);
      drawSpeechBubbles();  // globos encima de todo
      requestAnimationFrame(loop);
    }

    // ── Puntero + Drag ──
// Nota: usamos Pointer Events para soportar mouse y touch con el mismo código.
canvas.addEventListener('pointerdown', (e) => {
  const p = pointerPos(e);
  mouseX = p.x;
  mouseY = p.y;

  if (e.pointerType === 'mouse') {
    cursorEl.style.left = e.clientX + 'px';
    cursorEl.style.top  = e.clientY + 'px';
  }

  const me = myUid ? bubbles.get(myUid) : null;
  if (me && isOverBubble(me, p.x, p.y)) {
    drag.active = true;
    drag.pointerId = e.pointerId;
    drag.offsetX = me.x - p.x;
    drag.offsetY = me.y - p.y;
    me.vx = 0; me.vy = 0;

    try { canvas.setPointerCapture(e.pointerId); } catch(_) {}
    e.preventDefault();
  }
}, { passive: false });

canvas.addEventListener('pointermove', (e) => {
  const p = pointerPos(e);
  mouseX = p.x;
  mouseY = p.y;

  if (e.pointerType === 'mouse') {
    cursorEl.style.left = e.clientX + 'px';
    cursorEl.style.top  = e.clientY + 'px';
  }

  if (!drag.active || drag.pointerId !== e.pointerId) return;

  const me = myUid ? bubbles.get(myUid) : null;
  if (!me) return;

  const canvasH = canvas.height - BOT_PAD;
  const nx = p.x + drag.offsetX;
  const ny = p.y + drag.offsetY;

  me.x = clamp(nx, COLLISION_RADIUS, canvas.width - COLLISION_RADIUS);
  me.y = clamp(ny, TOP_PAD + COLLISION_RADIUS, canvasH - COLLISION_RADIUS);
  me.vx = 0;
  me.vy = 0;

  e.preventDefault();
}, { passive: false });

function endDrag(e) {
  if (!drag.active) return;
  if (drag.pointerId !== null && e.pointerId !== undefined && e.pointerId !== drag.pointerId) return;

  drag.active = false;
  drag.pointerId = null;
  drag.offsetX = 0;
  drag.offsetY = 0;

  try { canvas.releasePointerCapture(e.pointerId); } catch(_) {}
}

canvas.addEventListener('pointerup', endDrag);
canvas.addEventListener('pointercancel', endDrag);
window.addEventListener('pointerup', endDrag);

// Mantener cursor visible solo para mouse
window.addEventListener('mousemove', (e) => {
  cursorEl.style.left = e.clientX + 'px';
  cursorEl.style.top  = e.clientY + 'px';
});

// ── Firebase Auth + ROOM ──
    onAuthStateChanged(auth, async (user) => {
      if (!user) {
        try {
          await signInWithPopup(auth, new GoogleAuthProvider());
        } catch(e) {
          showToast('Error al iniciar sesión');
        }
        return;
      }

      myUid = user.uid;

      const { get } = await import('https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js');
      const snap = await get(ref(db, `users/${user.uid}`));
      const userData = snap.exists() ? snap.val() : {};

      const myData = {
        username:    userData.username    || user.displayName || 'Usuario',
        avatar:      userData.avatar      || '',
        photoURL:    user.photoURL        || '',
        borderColor: userData.borderColor || '#00c8ff',
        online: true,
        lastSeen: serverTimestamp(),
      };

      const presRef = ref(db, `presencia/${user.uid}`);
      await set(presRef, myData);
      onDisconnect(presRef).remove();

      // Escuchar presencia
      onValue(ref(db, 'presencia'), (snap) => {
        const online = new Set();

        if (snap.exists()) {
          snap.forEach(child => {
            const uid  = child.key;
            const data = child.val();
            online.add(uid);

            if (bubbles.has(uid)) {
              const b = bubbles.get(uid);
              b.username    = data.username    || b.username;
              b.avatar      = data.avatar      || b.avatar;
              b.photoURL    = data.photoURL    || b.photoURL;
              b.borderColor = data.borderColor || b.borderColor;
            } else {
              const b = createBubble(uid, data);
              b.img = loadImg(data.photoURL || data.avatar);
              bubbles.set(uid, b);
              if (uid !== myUid) showToast(`${data.username || 'Usuario'} se unió`);
            }
          });
        }

        for (const uid of bubbles.keys()) {
          if (!online.has(uid)) {
            const b = bubbles.get(uid);
            showToast(`${b.username} se fue`);
            bubbles.delete(uid);
          }
        }

        document.getElementById('onlineNum').textContent = bubbles.size;
      });

      // ── Escuchar mensajes en tiempo real ──
      // Registrar momento de conexión; ignorar mensajes anteriores a él.
      // Para mensajes propios recién enviados el serverTimestamp llega como null
      // en el evento local optimista, por eso también los mostramos.
      const conectadoEn = Date.now();

      onChildAdded(query(ref(db, 'mensajes'), limitToLast(50)), (snap) => {
        const msg = snap.val();
        if (!msg || !msg.uid || !msg.text) return;
        const ts = msg.timestamp;
        const esNuevo = ts !== null && ts !== undefined && ts >= conectadoEn;
        const esMio   = msg.uid === myUid && (ts === null || ts === undefined);
        if (esNuevo || esMio) {
          addSpeechBubble(msg.uid, msg.text);
        }
      });

      loading.style.display = 'none';
      loop();
    });

    // ── Enviar mensaje ──
    async function sendMessage() {
      if (!myUid) return;
      const input = document.getElementById('msg-input');
      const text  = input.value.trim();
      if (!text) return;

      input.value = '';

      // Mostrar globo propio inmediatamente (sin esperar Firebase)
      addSpeechBubble(myUid, text);

      // Guardar en Firebase para que todos los demás lo vean
      const msgsRef = ref(db, 'mensajes');
      await push(msgsRef, {
        uid:       myUid,
        text,
        timestamp: serverTimestamp(),
      });
    }

    document.getElementById('msg-send').addEventListener('click', sendMessage);
    document.getElementById('msg-input').addEventListener('keydown', e => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });

    // ── Toast ──
    let toastTimer;
    function showToast(msg) {
      const el = document.getElementById('toast');
      el.textContent = msg;
      el.classList.add('show');
      clearTimeout(toastTimer);
      toastTimer = setTimeout(() => el.classList.remove('show'), 3000);
    }
  </script>
</body>
</html>
