<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>ROOM · AEMX</title>
  <link rel="icon" type="image/png" href="imagen_1.png">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #060b14;
      --glow: #00c8ff;
      --gold: #ffd700;
      --text2: #6b8ab0;
      --border: #1a3a5c;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      background: var(--bg);
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      font-family: 'Share Tech Mono', monospace;
      cursor: none;
    }

    body::before {
      content: '';
      position: fixed;
      inset: 0;
      background-image:
        linear-gradient(rgba(0,200,255,0.04) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0,200,255,0.04) 1px, transparent 1px);
      background-size: 48px 48px;
      animation: gridMove 25s linear infinite;
      pointer-events: none;
      z-index: 0;
    }
    @keyframes gridMove {
      0%   { transform: translateY(0); }
      100% { transform: translateY(48px); }
    }

    body::after {
      content: '';
      position: fixed;
      inset: 0;
      background:
        radial-gradient(ellipse at 15% 20%, rgba(0,200,255,0.06) 0%, transparent 55%),
        radial-gradient(ellipse at 85% 80%, rgba(255,215,0,0.05) 0%, transparent 55%);
      pointer-events: none;
      z-index: 0;
    }

    #canvas {
      position: fixed;
      inset: 0;
      z-index: 1;
      touch-action: none;
    }

    /* HUD superior */
    .hud {
      position: fixed;
      top: 0; left: 0; right: 0;
      z-index: 10;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 14px 20px;
      border-bottom: 1px solid rgba(0,200,255,0.12);
      background: rgba(6,11,20,0.7);
      backdrop-filter: blur(12px);
    }

    .hud-title {
      font-family: 'Orbitron', monospace;
      font-size: 13px;
      font-weight: 900;
      letter-spacing: 5px;
      color: var(--glow);
      text-shadow: 0 0 20px rgba(0,200,255,0.5);
    }

    .hud-right {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .online-count {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 11px;
      color: var(--text2);
      letter-spacing: 2px;
    }

    .online-dot {
      width: 7px; height: 7px;
      border-radius: 50%;
      background: #00ff9d;
      box-shadow: 0 0 8px #00ff9d;
      animation: pulse 1.5s ease infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50%       { opacity: 0.4; transform: scale(0.7); }
    }

    .online-num {
      font-family: 'Orbitron', monospace;
      font-size: 16px;
      font-weight: 700;
      color: #00ff9d;
    }

    .btn-back {
      background: none;
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text2);
      font-family: 'Share Tech Mono', monospace;
      font-size: 11px;
      letter-spacing: 1px;
      padding: 5px 12px;
      cursor: pointer;
      text-decoration: none;
      transition: all 0.2s;
    }
    .btn-back:hover { border-color: var(--glow); color: var(--glow); }

    /* Cursor personalizado */
    #cursor {
      position: fixed;
      width: 12px; height: 12px;
      border: 2px solid var(--glow);
      border-radius: 50%;
      pointer-events: none;
      z-index: 100;
      transform: translate(-50%, -50%);
      transition: transform 0.1s ease;
      box-shadow: 0 0 10px rgba(0,200,255,0.6);
    }

    /* Loading */
    .loading {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 20;
      gap: 16px;
    }
    .loading-ring {
      width: 48px; height: 48px;
      border: 2px solid var(--border);
      border-top-color: var(--glow);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .loading-text {
      font-family: 'Orbitron', monospace;
      font-size: 10px;
      color: var(--text2);
      letter-spacing: 3px;
    }

    /* Toast */
    .toast {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%) translateY(60px);
      background: rgba(11,22,38,0.95);
      border: 1px solid var(--glow);
      border-radius: 8px;
      padding: 8px 20px;
      font-size: 11px;
      color: var(--glow);
      letter-spacing: 1px;
      z-index: 50;
      transition: transform 0.3s ease, opacity 0.3s ease;
      opacity: 0;
      white-space: nowrap;
    }
    .toast.show { transform: translateX(-50%) translateY(0); opacity: 1; }

    /* ── BARRA DE MENSAJE ── */
    #msg-bar {
      position: fixed;
      bottom: 0; left: 0; right: 0;
      z-index: 15;
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 16px;
      background: rgba(6,11,20,0.85);
      backdrop-filter: blur(16px);
      border-top: 1px solid rgba(0,200,255,0.15);
    }

    #msg-input {
      flex: 1;
      background: rgba(0,200,255,0.05);
      border: 1px solid rgba(0,200,255,0.2);
      border-radius: 8px;
      color: #cce8f4;
      font-family: 'Share Tech Mono', monospace;
      font-size: 13px;
      padding: 9px 14px;
      outline: none;
      transition: border-color 0.2s, box-shadow 0.2s;
      caret-color: var(--glow);
      cursor: text;
    }
    #msg-input::placeholder { color: rgba(107,138,176,0.5); }
    #msg-input:focus {
      border-color: rgba(0,200,255,0.55);
      box-shadow: 0 0 12px rgba(0,200,255,0.12);
    }

    #msg-send {
      background: rgba(0,200,255,0.1);
      border: 1px solid rgba(0,200,255,0.35);
      border-radius: 8px;
      color: var(--glow);
      font-family: 'Orbitron', monospace;
      font-size: 10px;
      font-weight: 700;
      letter-spacing: 2px;
      padding: 9px 18px;
      cursor: pointer;
      transition: all 0.2s;
      white-space: nowrap;
    }
    #msg-send:hover {
      background: rgba(0,200,255,0.2);
      border-color: var(--glow);
      box-shadow: 0 0 14px rgba(0,200,255,0.25);
    }
    #msg-send:active { transform: scale(0.96); }

    /* hint de atajos */
    #msg-hint {
      font-size: 10px;
      color: rgba(107,138,176,0.4);
      letter-spacing: 1px;
      white-space: nowrap;
    }
  </style>
</head>
<body>

  <!-- HUD -->
  <div class="hud">
    <div class="hud-title">⬡ ROOM AEMX</div>
    <div class="hud-right">
      <div class="online-count">
        <div class="online-dot"></div>
        <span class="online-num" id="onlineNum">0</span>
        <span>EN LÍNEA</span>
      </div>
      <a href="index.html" class="btn-back">← VOLVER</a>
    </div>
  </div>

  <!-- Canvas -->
  <canvas id="canvas"></canvas>

  <!-- Cursor -->
  <div id="cursor"></div>

  <!-- Loading -->
  <div class="loading" id="loading">
    <div class="loading-ring"></div>
    <div class="loading-text">CONECTANDO...</div>
  </div>

  <!-- Toast -->
  <div class="toast" id="toast"></div>

  <!-- Barra de mensajes -->
  <div id="msg-bar">
    <input id="msg-input" type="text" placeholder="Escribe un mensaje... (Enter para enviar)" maxlength="120" autocomplete="off" spellcheck="false">
    <span id="msg-hint">↵ ENVIAR</span>
    <button id="msg-send">TRANSMITIR</button>
  </div>

  <script type="module">
    import { initializeApp }  from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js';
    import { getAuth, onAuthStateChanged, GoogleAuthProvider, signInWithPopup }
                              from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js';
    import { getDatabase, ref, set, onValue, onChildAdded, onDisconnect, serverTimestamp, remove, push, query, limitToLast }
                              from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js';

    const firebaseConfig = {
      apiKey:        'AIzaSyB-xx2PlBjvnHe0K7Bf1MspVqUlfjky0mk',
      authDomain:    'aemx-chat.firebaseapp.com',
      databaseURL:   'https://aemx-chat-default-rtdb.firebaseio.com',
      projectId:     'aemx-chat',
      storageBucket: 'aemx-chat.appspot.com',
    };

    const app  = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db   = getDatabase(app);

    // ── Canvas setup ──
    const canvas  = document.getElementById('canvas');
    const ctx     = canvas.getContext('2d');
    const loading = document.getElementById('loading');
    const cursorEl= document.getElementById('cursor');

    function resize() {
      canvas.width  = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    // ── Constantes de física ──
    const BASE_RADIUS     = 44;
    // Tamaño visual: ~1/3 más pequeño que antes (44 → ~29)
    const VISUAL_RADIUS   = Math.round(BASE_RADIUS * 0.67);
    // Área de colisión más grande (hitbox) para choques más frecuentes
    const RADIUS          = Math.round(BASE_RADIUS * 1.35);

    // Física (tuneada para que la inercia dure ~3× más)
    const FRICTION        = 0.965;
    const REPULSE         = 0.38;
    const WALL_BOUNCE     = 0.85; // rebote en paredes (más alto = más elástico)
    const TOP_PAD  = 60;
    const BOT_PAD  = 56; // espacio para la barra de mensajes

    const bubbles  = new Map(); // uid → burbuja
    const imgCache = new Map(); // url → HTMLImageElement

    // ── Globos de diálogo ──
    // Cada globo: { uid, text, born, duration, alpha, lines, boxW, boxH }
    const speechBubbles = [];
    const BUBBLE_DURATION = 6000; // ms que dura el globo
    const MSG_MAX_WIDTH   = 220;  // ancho máximo del texto

    function loadImg(url) {
      if (!url) return null;
      if (imgCache.has(url)) return imgCache.get(url);
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.src = url;
      imgCache.set(url, img);
      return img;
    }

    function createBubble(uid, data) {
      return {
        uid,
        username:    data.username || '?',
        avatar:      data.avatar   || '',
        borderColor: data.borderColor || '#00c8ff',
        photoURL:    (data.photoURL || ''),
        x: RADIUS + Math.random() * (canvas.width  - RADIUS * 2),
        y: TOP_PAD + RADIUS + Math.random() * (canvas.height - TOP_PAD - BOT_PAD - RADIUS * 2),
        vx: (Math.random() - 0.5) * 2,
        vy: (Math.random() - 0.5) * 2,
        ringAngle: Math.random() * Math.PI * 2,
        img: null,
        pulse: 0,
      };
    }

    // ── Física ──
    let myUid  = null;

    function updatePhysics() {
      const bArr = [...bubbles.values()];
      const canvasH = canvas.height - BOT_PAD;

      for (let i = 0; i < bArr.length; i++) {
        const b = bArr[i];

        if (b.uid !== myUid) {
          const cx = canvas.width / 2, cy = (TOP_PAD + canvasH) / 2;
          b.vx += (cx - b.x) * 0.002;
          b.vy += (cy - b.y) * 0.002;
        }

        b.vx *= FRICTION;
        b.vy *= FRICTION;
        b.x += b.vx;
        b.y += b.vy;

        if (b.x < RADIUS)                 { b.x = RADIUS;                 b.vx *= -WALL_BOUNCE; }
        if (b.x > canvas.width - RADIUS)  { b.x = canvas.width - RADIUS;  b.vx *= -WALL_BOUNCE; }
        if (b.y < TOP_PAD + RADIUS)       { b.y = TOP_PAD + RADIUS;        b.vy *= -WALL_BOUNCE; }
        if (b.y > canvasH - RADIUS)       { b.y = canvasH - RADIUS;        b.vy *= -WALL_BOUNCE; }

        for (let j = i + 1; j < bArr.length; j++) {
          const o  = bArr[j];
          const dx = o.x - b.x;
          const dy = o.y - b.y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 0.01;
          const minDist = RADIUS * 2 + 8;

          if (dist < minDist) {
            const force = (minDist - dist) / minDist * REPULSE;
            const nx = dx / dist, ny = dy / dist;
            const bPinned = (b.uid === myUid && isDragging);
const oPinned = (o.uid === myUid && isDragging);

// Si estoy arrastrando mi avatar, se comporta como "objeto fijo":
// empuja a los demás, pero a mí no me empujan.
if (!bPinned) { b.vx -= nx * force; b.vy -= ny * force; }
if (!oPinned) { o.vx += nx * force; o.vy += ny * force; }
          }
        }

        b.ringAngle += 0.008;
        if (b.pulse < 1) b.pulse = Math.min(1, b.pulse + 0.04);
      }
    }

    // ── Utilidades de texto ──
    function wrapText(text, maxWidth) {
      ctx.font = '12px "Share Tech Mono", monospace';
      const words = text.split(' ');
      const lines = [];
      let current = '';

      for (const word of words) {
        const test = current ? current + ' ' + word : word;
        if (ctx.measureText(test).width > maxWidth && current) {
          lines.push(current);
          current = word;
        } else {
          current = test;
        }
      }
      if (current) lines.push(current);
      return lines;
    }

    // ── Dibujar globo de diálogo ──
    function drawSpeechBubbles() {
      const now = performance.now();

      for (let i = speechBubbles.length - 1; i >= 0; i--) {
        const sb = speechBubbles[i];
        const bubble = bubbles.get(sb.uid);
        if (!bubble) { speechBubbles.splice(i, 1); continue; }

        const elapsed = now - sb.born;
        if (elapsed > sb.duration) { speechBubbles.splice(i, 1); continue; }

        // fade in/out
        let alpha = 1;
        const fadeIn  = 300;
        const fadeOut = 800;
        if (elapsed < fadeIn) {
          alpha = elapsed / fadeIn;
        } else if (elapsed > sb.duration - fadeOut) {
          alpha = (sb.duration - elapsed) / fadeOut;
        }
        alpha = Math.max(0, Math.min(1, alpha));

        const { x, y } = bubble;
        const color = bubble.borderColor || '#00c8ff';

        // Calcular dimensiones del box
        ctx.font = '12px "Share Tech Mono", monospace';
        const lineH = 17;
        const padX  = 12, padY = 9;
        const boxW  = sb.boxW;
        const boxH  = sb.lines.length * lineH + padY * 2;

        // Posición del globo (arriba del avatar)
        const tailH  = 10;
        const bx     = x - boxW / 2;
        const by     = y - VISUAL_RADIUS - tailH - boxH - 8;

        ctx.save();
        ctx.globalAlpha = alpha;

        // Fondo del globo
        const fillColor = hexToRgba(color, 0.12);
        const borderCol = hexToRgba(color, 0.75);

        // Sombra glow
        ctx.shadowColor = color;
        ctx.shadowBlur  = 18;

        // Cuerpo del globo (rounded rect)
        const rx = 10;
        ctx.beginPath();
        ctx.moveTo(bx + rx, by);
        ctx.lineTo(bx + boxW - rx, by);
        ctx.quadraticCurveTo(bx + boxW, by, bx + boxW, by + rx);
        ctx.lineTo(bx + boxW, by + boxH - rx);
        ctx.quadraticCurveTo(bx + boxW, by + boxH, bx + boxW - rx, by + boxH);
        // cola del globo
        const midX = x;
        ctx.lineTo(midX + 8, by + boxH);
        ctx.lineTo(midX, by + boxH + tailH);
        ctx.lineTo(midX - 8, by + boxH);
        ctx.lineTo(bx + rx, by + boxH);
        ctx.quadraticCurveTo(bx, by + boxH, bx, by + boxH - rx);
        ctx.lineTo(bx, by + rx);
        ctx.quadraticCurveTo(bx, by, bx + rx, by);
        ctx.closePath();

        ctx.fillStyle = fillColor;
        ctx.fill();

        ctx.shadowBlur = 0;
        ctx.strokeStyle = borderCol;
        ctx.lineWidth   = 1.5;
        ctx.stroke();

        // Texto
        ctx.shadowColor = color;
        ctx.shadowBlur  = 6;
        ctx.fillStyle   = '#e8f4ff';
        ctx.font        = '12px "Share Tech Mono", monospace';
        ctx.textAlign   = 'left';
        ctx.textBaseline= 'top';

        sb.lines.forEach((line, idx) => {
          ctx.fillText(line, bx + padX, by + padY + idx * lineH);
        });

        ctx.restore();
      }
    }

    // ── Recibir mensaje y crear globo ──
    function addSpeechBubble(uid, text) {
      // Calcular ancho máximo según canvas
      const maxW = Math.min(MSG_MAX_WIDTH, canvas.width * 0.4);
      ctx.font = '12px "Share Tech Mono", monospace';
      const lines = wrapText(text, maxW - 24);
      let boxW = 0;
      lines.forEach(l => { boxW = Math.max(boxW, ctx.measureText(l).width + 24); });
      boxW = Math.max(boxW, 80);

      // Eliminar globo anterior del mismo uid
      const existIdx = speechBubbles.findIndex(sb => sb.uid === uid);
      if (existIdx !== -1) speechBubbles.splice(existIdx, 1);

      speechBubbles.push({
        uid,
        text,
        born: performance.now(),
        duration: BUBBLE_DURATION,
        lines,
        boxW,
      });
    }

    // ── Dibujar avatar ──
    function drawBubble(b) {
      const { x, y, username, borderColor, avatar, photoURL, ringAngle, pulse } = b;
      const scale = 0.4 + pulse * 0.6;
      const r = VISUAL_RADIUS * scale;
      const isMe = b.uid === myUid;

      ctx.save();
      ctx.translate(x, y);
      ctx.scale(scale, scale);

      ctx.shadowColor = borderColor;
      ctx.shadowBlur  = isMe ? 28 : 16;

      const ringR    = VISUAL_RADIUS + 10;
      const segments = 12;
      for (let i = 0; i < segments; i++) {
        const a1 = ringAngle + (i / segments) * Math.PI * 2;
        const a2 = a1 + (Math.PI * 2 / segments) * 0.6;
        const alpha = (i % 2 === 0) ? 0.9 : 0.25;
        ctx.beginPath();
        ctx.arc(0, 0, ringR, a1, a2);
        ctx.strokeStyle = hexToRgba(borderColor, alpha);
        ctx.lineWidth   = isMe ? 3.5 : 2.5;
        ctx.lineCap     = 'round';
        ctx.stroke();
      }
      ctx.shadowBlur = 0;

      ctx.beginPath();
      ctx.arc(0, 0, VISUAL_RADIUS, 0, Math.PI * 2);
      ctx.clip();

      ctx.fillStyle = '#0b1626';
      ctx.fill();

      const imgSrc = avatar || photoURL;
      if (imgSrc) {
        const img = loadImg(imgSrc);
        if (img && img.complete && img.naturalWidth > 0) {
          try {
            ctx.drawImage(img, -VISUAL_RADIUS, -VISUAL_RADIUS, VISUAL_RADIUS * 2, VISUAL_RADIUS * 2);
          } catch(e) {
            drawInitial(ctx, username, borderColor);
          }
        } else {
          drawInitial(ctx, username, borderColor);
        }
      } else {
        drawInitial(ctx, username, borderColor);
      }

      ctx.restore();

      ctx.save();
      ctx.translate(x, y);
      ctx.beginPath();
      ctx.arc(0, 0, r, 0, Math.PI * 2);
      ctx.strokeStyle = hexToRgba(borderColor, 0.7);
      ctx.lineWidth   = 2;
      ctx.shadowColor = borderColor;
      ctx.shadowBlur  = 10;
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.translate(x, y);
      const label = isMe ? `${username} ◀` : username;
      ctx.font         = `bold ${isMe ? 11 : 10}px "Share Tech Mono", monospace`;
      ctx.textAlign    = 'center';
      ctx.textBaseline = 'top';
      const tw = ctx.measureText(label).width;
      ctx.fillStyle = 'rgba(6,11,20,0.85)';
      ctx.beginPath();
      ctx.roundRect(-tw/2 - 6, r + 6, tw + 12, 18, 4);
      ctx.fill();
      ctx.fillStyle   = isMe ? '#ffd700' : borderColor;
      ctx.shadowColor = isMe ? '#ffd700' : borderColor;
      ctx.shadowBlur  = 6;
      ctx.fillText(label, 0, r + 8);
      ctx.restore();
    }

    function drawInitial(ctx, username, color) {
      const letter = (username || '?').charAt(0).toUpperCase();
      ctx.fillStyle = hexToRgba(color, 0.18);
      ctx.fillRect(-RADIUS, -RADIUS, RADIUS * 2, RADIUS * 2);
      ctx.font         = `bold ${RADIUS * 0.9}px "Orbitron", monospace`;
      ctx.textAlign    = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle    = color;
      ctx.shadowColor  = color;
      ctx.shadowBlur   = 12;
      ctx.fillText(letter, 0, 2);
    }

    function hexToRgba(hex, alpha) {
      if (!hex || !hex.startsWith('#')) return `rgba(0,200,255,${alpha})`;
      const r = parseInt(hex.slice(1,3), 16);
      const g = parseInt(hex.slice(3,5), 16);
      const b = parseInt(hex.slice(5,7), 16);
      return `rgba(${r},${g},${b},${alpha})`;
    }

    // ── Loop principal ──
    function loop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const bArr = [...bubbles.values()];
      for (let i = 0; i < bArr.length; i++) {
        for (let j = i + 1; j < bArr.length; j++) {
          const a = bArr[i], b = bArr[j];
          const dx = b.x - a.x, dy = b.y - a.y;
          const dist = Math.sqrt(dx*dx + dy*dy);
          const maxDist = 180;
          if (dist < maxDist) {
            const alpha = (1 - dist / maxDist) * 0.15;
            ctx.beginPath();
            ctx.moveTo(a.x, a.y);
            ctx.lineTo(b.x, b.y);
            ctx.strokeStyle = `rgba(0,200,255,${alpha})`;
            ctx.lineWidth   = 1;
            ctx.stroke();
          }
        }
      }

      updatePhysics();
      bArr.forEach(drawBubble);
      drawSpeechBubbles();  // globos encima de todo
      requestAnimationFrame(loop);
    }

    
// ── Interacción (drag con inercia) ──
// Nota: ya NO se usa el puntero para "atraer" al avatar.
let isDragging = false;
let dragUid = null;

// Velocidad estimada durante el arrastre (para inercia al soltar)
let dragVx = 0, dragVy = 0;
let lastPX = 0, lastPY = 0, lastPT = 0;

// Radio cómodo para agarrar en móvil (más grande que el avatar visual)
const DRAG_RADIUS = Math.max(VISUAL_RADIUS * 1.9, 44);

function clampToRoom(x, y) {
  const canvasH = canvas.height - BOT_PAD;
  const cx = Math.max(RADIUS, Math.min(canvas.width - RADIUS, x));
  const cy = Math.max(TOP_PAD + RADIUS, Math.min(canvasH - RADIUS, y));
  return { x: cx, y: cy };
}

canvas.addEventListener('pointerdown', (e) => {
  if (!myUid) return;
  const me = bubbles.get(myUid);
  if (!me) return;

  const px = e.clientX;
  const py = e.clientY;

  const dx = px - me.x;
  const dy = py - me.y;
  const dist = Math.hypot(dx, dy);

  if (dist <= DRAG_RADIUS) {
    isDragging = true;
    dragUid = myUid;

    // Reinicia acumulador de velocidad
    dragVx = 0; dragVy = 0;
    lastPX = px; lastPY = py; lastPT = performance.now();

    // Durante drag, evita que el sistema "recupere" al centro
    me.vx = 0; me.vy = 0;

    canvas.setPointerCapture(e.pointerId);
  }
});

canvas.addEventListener('pointermove', (e) => {
  // Cursor visual solo desktop
  if (e.pointerType === 'mouse') {
    cursorEl.style.left = e.clientX + 'px';
    cursorEl.style.top  = e.clientY + 'px';
  }

  if (!isDragging || dragUid !== myUid) return;
  const me = bubbles.get(myUid);
  if (!me) return;

  const now = performance.now();
  const dt = Math.max(8, now - lastPT); // ms (evita dt demasiado pequeño)
  const px = e.clientX;
  const py = e.clientY;

  const { x, y } = clampToRoom(px, py);
  // Estima velocidad en "px por frame" (normalizado a 60fps)
  const norm = 16.6667 / dt;
  const instVx = (x - me.x) * norm;
  const instVy = (y - me.y) * norm;

  // Suavizado para que no "latiguee"
  dragVx = dragVx * 0.6 + instVx * 0.4;
  dragVy = dragVy * 0.6 + instVy * 0.4;

  me.x = x;
  me.y = y;
  me.vx = 0;
  me.vy = 0;

  lastPX = px; lastPY = py; lastPT = now;
});

function endDrag(e) {
  if (!isDragging || dragUid !== myUid) return;
  const me = bubbles.get(myUid);
  if (me) {
    // Inercia al soltar
    me.vx = dragVx;
    me.vy = dragVy;
  }
  isDragging = false;
  dragUid = null;
  try { canvas.releasePointerCapture(e.pointerId); } catch (_) {}
}

canvas.addEventListener('pointerup', endDrag);
canvas.addEventListener('pointercancel', endDrag);

// Oculta el cursor en pantallas táctiles
window.addEventListener('pointerdown', (e) => {
  if (e.pointerType !== 'mouse') cursorEl.style.display = 'none';
}, { passive: true });


    // ── Firebase Auth + ROOM ──
    onAuthStateChanged(auth, async (user) => {
      if (!user) {
        try {
          await signInWithPopup(auth, new GoogleAuthProvider());
        } catch(e) {
          showToast('Error al iniciar sesión');
        }
        return;
      }

      myUid = user.uid;

      const { get } = await import('https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js');
      const snap = await get(ref(db, `users/${user.uid}`));
      const userData = snap.exists() ? snap.val() : {};

      const myData = {
        username:    userData.username    || user.displayName || 'Usuario',
        avatar:      userData.avatar      || '',
        photoURL:    (userData.avatar ? '' : (user.photoURL || '')),
        borderColor: userData.borderColor || '#00c8ff',
        online: true,
        lastSeen: serverTimestamp(),
      };

      const presRef = ref(db, `presencia/${user.uid}`);
      await set(presRef, myData);
      onDisconnect(presRef).remove();

      // Escuchar presencia
      onValue(ref(db, 'presencia'), (snap) => {
        const online = new Set();

        if (snap.exists()) {
          snap.forEach(child => {
            const uid  = child.key;
            const data = child.val();
            online.add(uid);

            if (bubbles.has(uid)) {
              const b = bubbles.get(uid);
              b.username    = data.username    || b.username;
              b.avatar      = data.avatar      || b.avatar;
              b.photoURL    = data.photoURL    || b.photoURL;
              b.borderColor = data.borderColor || b.borderColor;
            } else {
              const b = createBubble(uid, data);
              b.img = loadImg((data.avatar || '') || (data.photoURL || ''));
              bubbles.set(uid, b);
              if (uid !== myUid) showToast(`${data.username || 'Usuario'} se unió`);
            }
          });
        }

        for (const uid of bubbles.keys()) {
          if (!online.has(uid)) {
            const b = bubbles.get(uid);
            showToast(`${b.username} se fue`);
            bubbles.delete(uid);
          }
        }

        document.getElementById('onlineNum').textContent = bubbles.size;
      });

      // ── Escuchar mensajes en tiempo real ──
      // Registrar momento de conexión; ignorar mensajes anteriores a él.
      // Para mensajes propios recién enviados el serverTimestamp llega como null
      // en el evento local optimista, por eso también los mostramos.
      // ── Sincronía de tiempo con servidor (evita bugs por reloj del dispositivo) ──
let serverOffset = 0;
onValue(ref(db, '.info/serverTimeOffset'), (snap) => {
  serverOffset = snap.val() || 0;
});
const serverNow = () => Date.now() + serverOffset;

// ── Mensajes (burbujas sobre avatares) ──
// Mostramos mensajes recientes para evitar que al recargar aparezcan "historiales" viejos.
// El tiempo se calcula con el reloj del servidor para que todos vean lo mismo.
const MSG_RECENT_MS = 30 * 1000; // 30s de ventana (la burbuja dura 6s)

onChildAdded(query(ref(db, 'mensajes'), limitToLast(50)), (snap) => {
  const msg = snap.val();
  if (!msg || !msg.uid || !msg.text) return;

  const ts = (typeof msg.timestamp === 'number') ? msg.timestamp : null;
  if (ts !== null && (serverNow() - ts) > MSG_RECENT_MS) return;

  addSpeechBubble(msg.uid, msg.text);
});

loading.style.display = 'none';
      loop();
    });

    // ── Enviar mensaje ──
    async function sendMessage() {
      if (!myUid) return;
      const input = document.getElementById('msg-input');
      const text  = input.value.trim();
      if (!text) return;

      input.value = '';

      // Mostrar globo propio inmediatamente (sin esperar Firebase)
      addSpeechBubble(myUid, text);

      // Guardar en Firebase para que todos los demás lo vean
      const msgsRef = ref(db, 'mensajes');
      await push(msgsRef, {
        uid:       myUid,
        text,
        timestamp: serverTimestamp(),
      });
    }

    document.getElementById('msg-send').addEventListener('click', sendMessage);
    document.getElementById('msg-input').addEventListener('keydown', e => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });

    // ── Toast ──
    let toastTimer;
    function showToast(msg) {
      const el = document.getElementById('toast');
      el.textContent = msg;
      el.classList.add('show');
      clearTimeout(toastTimer);
      toastTimer = setTimeout(() => el.classList.remove('show'), 3000);
    }
  </script>
</body>
</html>
